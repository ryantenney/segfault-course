#!/usr/bin/env bash
# Convenience wrapper around cmake and ctest.
#
# Usage:
#   ./run build                  # Configure + build all exercises
#   ./run lesson 01-01           # Build & test course 01, lesson 01
#   ./run exercise 01-01-ex01    # Build & test a single exercise
#   ./run course 01              # Build & test all of course 01
#   ./run all                    # Build & test everything
#   ./run clean                  # Remove build directory

set -euo pipefail

ROOT_DIR="$(cd "$(dirname "$0")" && pwd)"
BUILD_DIR="$ROOT_DIR/build"

# --------------------------------------------------------------------------
# Helpers
# --------------------------------------------------------------------------

ensure_configured() {
    if [[ ! -f "$BUILD_DIR/CMakeCache.txt" ]]; then
        echo "-- Configuring build..."
        cmake -S "$ROOT_DIR" -B "$BUILD_DIR" -DCMAKE_BUILD_TYPE=Debug
    fi
}

build_target() {
    ensure_configured
    local cmake_args=(--build "$BUILD_DIR" -j "$(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 4)")
    if [[ $# -eq 0 ]]; then
        cmake_args+=(--target all)
    else
        for target in "$@"; do
            cmake_args+=(--target "$target")
        done
    fi
    cmake "${cmake_args[@]}"
}

# Lists test names matching a ctest regex filter.
discover_tests() {
    local filter="$1"
    ensure_configured
    ctest --test-dir "$BUILD_DIR" -N --no-tests=ignore -R "$filter" 2>/dev/null \
        | sed -n 's/.*Test #[0-9]*: //p'
}

run_tests() {
    local pattern="${1:-[0-9]*-ex*}"

    # Find matching test binaries in the build tree.
    local binaries=()
    while IFS= read -r path; do
        [[ -x "$path" ]] && binaries+=("$path")
    done < <(find "$BUILD_DIR/courses" -type f -name "$pattern" 2>/dev/null | sort)

    if [[ ${#binaries[@]} -eq 0 ]]; then
        echo "No tests matched: $pattern"
        return 1
    fi

    local total_passed=0 total_failed=0 total_skipped=0
    local exercise_failures=()

    for binary in "${binaries[@]}"; do
        local rc=0
        local output
        output=$("$binary" 2>&1) || rc=$?
        echo "$output"

        # Parse the summary line for aggregate counts.
        local p=0 f=0 s=0
        if [[ "$output" =~ ([0-9]+)\ passed ]]; then p="${BASH_REMATCH[1]}"; fi
        if [[ "$output" =~ ([0-9]+)\ failed ]]; then f="${BASH_REMATCH[1]}"; fi
        if [[ "$output" =~ ([0-9]+)\ skipped ]]; then s="${BASH_REMATCH[1]}"; fi

        total_passed=$((total_passed + p))
        total_failed=$((total_failed + f))
        total_skipped=$((total_skipped + s))

        if [[ $rc -gt 1 ]]; then
            # Exit code > 1 means crash (e.g. segfault = 139).
            local name
            name=$(basename "$binary")
            printf "  \033[31m✗ %s crashed (exit code %d)\033[0m\n\n" "$name" "$rc"
            exercise_failures+=("$name")
        elif [[ $f -gt 0 ]]; then
            exercise_failures+=("$(basename "$binary")")
        fi
    done

    # Grand summary (only when running more than one exercise).
    if [[ ${#binaries[@]} -gt 1 ]]; then
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        printf " \033[1m%d passed" "$total_passed"
        if [[ $total_failed -gt 0 ]]; then printf ", \033[31m%d failed\033[0;1m" "$total_failed"; fi
        if [[ $total_skipped -gt 0 ]]; then printf ", \033[33m%d skipped\033[0;1m" "$total_skipped"; fi
        printf "\033[0m\n"
        if [[ ${#exercise_failures[@]} -gt 0 ]]; then
            printf " \033[31mFailed:\033[0m %s\n" "${exercise_failures[*]}"
        fi
        echo ""
    fi

    [[ $total_failed -eq 0 && ${#exercise_failures[@]} -eq 0 ]]
}

# --------------------------------------------------------------------------
# Commands
# --------------------------------------------------------------------------

cmd_build() {
    build_target
}

cmd_lesson() {
    local lesson="$1"
    local targets=()
    while IFS= read -r name; do
        [[ -n "$name" ]] && targets+=("$name")
    done < <(discover_tests "^${lesson}-")
    if [[ ${#targets[@]} -eq 0 ]]; then
        echo "No exercises found for lesson: $lesson"
        return 1
    fi
    build_target "${targets[@]}"
    run_tests "${lesson}-*"
}

cmd_exercise() {
    local exercise="$1"
    build_target "$exercise"
    run_tests "$exercise"
}

cmd_course() {
    local course="$1"
    local targets=()
    while IFS= read -r name; do
        [[ -n "$name" ]] && targets+=("$name")
    done < <(discover_tests "^${course}-")
    if [[ ${#targets[@]} -eq 0 ]]; then
        echo "No exercises found for course: $course"
        return 1
    fi
    build_target "${targets[@]}"
    run_tests "${course}-*"
}

cmd_all() {
    build_target
    run_tests
}

cmd_clean() {
    echo "-- Removing $BUILD_DIR"
    rm -rf "$BUILD_DIR"
}

# --------------------------------------------------------------------------
# Dispatch
# --------------------------------------------------------------------------

usage() {
    cat <<'EOF'
Usage:
  ./run build                  # Configure + build all exercises
  ./run lesson 01-01           # Build & test a lesson (course-lesson)
  ./run exercise 01-01-ex01    # Build & test a single exercise
  ./run course 01              # Build & test all of a course
  ./run all                    # Build & test everything
  ./run clean                  # Remove build directory
EOF
}

if [[ $# -lt 1 ]]; then
    usage
    exit 1
fi

command="$1"
shift

case "$command" in
    build)    cmd_build ;;
    lesson)   [[ $# -ge 1 ]] || { echo "Usage: ./run lesson <lesson-id>"; exit 1; }
              cmd_lesson "$1" ;;
    exercise) [[ $# -ge 1 ]] || { echo "Usage: ./run exercise <exercise-id>"; exit 1; }
              cmd_exercise "$1" ;;
    course)   [[ $# -ge 1 ]] || { echo "Usage: ./run course <course-id>"; exit 1; }
              cmd_course "$1" ;;
    all)      cmd_all ;;
    clean)    cmd_clean ;;
    *)        echo "Unknown command: $command"; usage; exit 1 ;;
esac
